###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      03/Feb/2017  14:32:20 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Андрей\Google Диск\Stand_MNI\Модем\src\stm32f4x #
#                    x_can.c                                                  #
#    Command line =  "C:\Users\Андрей\Google Диск\Stand_MNI\Модем\src\stm32f4 #
#                    xx_can.c" -D USE_STDPERIPH_DRIVER -D STM32F4XX -D        #
#                    USE_STM324xG_EVAL -D USE_USB_OTG_FS -lcN                 #
#                    "C:\Users\Андрей\Google Диск\Stand_MNI\Модем\STM324xG-EV #
#                    AL_USBD-FS\List\" -o "C:\Users\Андрей\Google             #
#                    Диск\Stand_MNI\Модем\STM324xG-EVAL_USBD-FS\Obj\"         #
#                    --debug --endian=little --cpu=Cortex-M4 -e --fpu=None    #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Users\Андрей\Google Диск\Stand_MNI\Модем\"   #
#                    -I "C:\Users\Андрей\Google Диск\Stand_MNI\Модем\inc\"    #
#                    -I "C:\Users\Андрей\Google Диск\Stand_MNI\Модем\src\"    #
#                    -Ohs --use_c++_inline -I "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.5\arm\CMSIS\Include\"       #
#    List file    =  C:\Users\Андрей\Google Диск\Stand_MNI\Модем\STM324xG-EVA #
#                    L_USBD-FS\List\stm32f4xx_can.lst                         #
#    Object file  =  C:\Users\Андрей\Google Диск\Stand_MNI\Модем\STM324xG-EVA #
#                    L_USBD-FS\Obj\stm32f4xx_can.o                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Андрей\Google Диск\Stand_MNI\Модем\src\stm32f4xx_can.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_can.c
      4            * @author  MCD Application Team
      5            * @version V1.0.2
      6            * @date    05-March-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Controller area network (CAN) peripheral:           
      9            *           - Initialization and Configuration 
     10            *           - CAN Frames Transmission 
     11            *           - CAN Frames Reception    
     12            *           - Operation modes switch  
     13            *           - Error management          
     14            *           - Interrupts and flags        
     15            *         
     16            *  @verbatim
     17            *                               
     18            *          ===================================================================      
     19            *                                   How to use this driver
     20            *          ===================================================================
     21                          
     22            *          1.  Enable the CAN controller interface clock using 
     23            *                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE); for CAN1 
     24            *              and RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2, ENABLE); for CAN2
     25            *  @note   In case you are using CAN2 only, you have to enable the CAN1 clock.
     26            *     
     27            *          2. CAN pins configuration
     28            *               - Enable the clock for the CAN GPIOs using the following function:
     29            *                   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
     30            *               - Connect the involved CAN pins to AF9 using the following function 
     31            *                   GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_CANx); 
     32            *                - Configure these CAN pins in alternate function mode by calling
     33            *                  the function  GPIO_Init();
     34            *    
     35            *          3.  Initialise and configure the CAN using CAN_Init() and 
     36            *               CAN_FilterInit() functions.   
     37            *               
     38            *          4.  Transmit the desired CAN frame using CAN_Transmit() function.
     39            *         
     40            *          5.  Check the transmission of a CAN frame using CAN_TransmitStatus()
     41            *              function.
     42            *               
     43            *          6.  Cancel the transmission of a CAN frame using CAN_CancelTransmit()
     44            *              function.  
     45            *            
     46            *          7.  Receive a CAN frame using CAN_Recieve() function.
     47            *         
     48            *          8.  Release the receive FIFOs using CAN_FIFORelease() function.
     49            *               
     50            *          9. Return the number of pending received frames using 
     51            *              CAN_MessagePending() function.            
     52            *                   
     53            *          10. To control CAN events you can use one of the following two methods:
     54            *               - Check on CAN flags using the CAN_GetFlagStatus() function.  
     55            *               - Use CAN interrupts through the function CAN_ITConfig() at 
     56            *                 initialization phase and CAN_GetITStatus() function into 
     57            *                 interrupt routines to check if the event has occurred or not.
     58            *             After checking on a flag you should clear it using CAN_ClearFlag()
     59            *             function. And after checking on an interrupt event you should 
     60            *             clear it using CAN_ClearITPendingBit() function.            
     61            *               
     62            *              
     63            *  @endverbatim
     64            *         
     65            ******************************************************************************
     66            * @attention
     67            *
     68            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     69            *
     70            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     71            * You may not use this file except in compliance with the License.
     72            * You may obtain a copy of the License at:
     73            *
     74            *        http://www.st.com/software_license_agreement_liberty_v2
     75            *
     76            * Unless required by applicable law or agreed to in writing, software 
     77            * distributed under the License is distributed on an "AS IS" BASIS, 
     78            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     79            * See the License for the specific language governing permissions and
     80            * limitations under the License.
     81            *
     82            ******************************************************************************
     83            */
     84          
     85          /* Includes ------------------------------------------------------------------*/
     86          #include "stm32f4xx_can.h"
     87          #include "stm32f4xx_rcc.h"
     88          
     89          /** @addtogroup STM32F4xx_StdPeriph_Driver
     90            * @{
     91            */
     92          
     93          /** @defgroup CAN 
     94            * @brief CAN driver modules
     95            * @{
     96            */ 
     97          /* Private typedef -----------------------------------------------------------*/
     98          /* Private define ------------------------------------------------------------*/
     99          
    100          /* CAN Master Control Register bits */
    101          #define MCR_DBF           ((uint32_t)0x00010000) /* software master reset */
    102          
    103          /* CAN Mailbox Transmit Request */
    104          #define TMIDxR_TXRQ       ((uint32_t)0x00000001) /* Transmit mailbox request */
    105          
    106          /* CAN Filter Master Register bits */
    107          #define FMR_FINIT         ((uint32_t)0x00000001) /* Filter init mode */
    108          
    109          /* Time out for INAK bit */
    110          #define INAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    111          /* Time out for SLAK bit */
    112          #define SLAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    113          
    114          /* Flags in TSR register */
    115          #define CAN_FLAGS_TSR     ((uint32_t)0x08000000) 
    116          /* Flags in RF1R register */
    117          #define CAN_FLAGS_RF1R    ((uint32_t)0x04000000) 
    118          /* Flags in RF0R register */
    119          #define CAN_FLAGS_RF0R    ((uint32_t)0x02000000) 
    120          /* Flags in MSR register */
    121          #define CAN_FLAGS_MSR     ((uint32_t)0x01000000) 
    122          /* Flags in ESR register */
    123          #define CAN_FLAGS_ESR     ((uint32_t)0x00F00000) 
    124          
    125          /* Mailboxes definition */
    126          #define CAN_TXMAILBOX_0   ((uint8_t)0x00)
    127          #define CAN_TXMAILBOX_1   ((uint8_t)0x01)
    128          #define CAN_TXMAILBOX_2   ((uint8_t)0x02) 
    129          
    130          #define CAN_MODE_MASK     ((uint32_t) 0x00000003)
    131          
    132          /* Private macro -------------------------------------------------------------*/
    133          /* Private variables ---------------------------------------------------------*/
    134          /* Private function prototypes -----------------------------------------------*/
    135          /* Private functions ---------------------------------------------------------*/
    136          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
    137          
    138          /** @defgroup CAN_Private_Functions
    139            * @{
    140            */
    141          
    142          /** @defgroup CAN_Group1 Initialization and Configuration functions
    143           *  @brief    Initialization and Configuration functions 
    144           *
    145          @verbatim    
    146           ===============================================================================
    147                                Initialization and Configuration functions
    148           ===============================================================================  
    149            This section provides functions allowing to 
    150             - Initialize the CAN peripherals : Prescaler, operating mode, the maximum number 
    151               of time quanta to perform resynchronization, the number of time quanta in
    152               Bit Segment 1 and 2 and many other modes. 
    153               Refer to  @ref CAN_InitTypeDef  for more details.
    154             - Configures the CAN reception filter.                                      
    155             - Select the start bank filter for slave CAN.
    156             - Enables or disables the Debug Freeze mode for CAN
    157             - Enables or disables the CAN Time Trigger Operation communication mode
    158             
    159          @endverbatim
    160            * @{
    161            */
    162            
    163          /**
    164            * @brief  Deinitializes the CAN peripheral registers to their default reset values.
    165            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    166            * @retval None.
    167            */
    168          void CAN_DeInit(CAN_TypeDef* CANx)
    169          {
    170            /* Check the parameters */
    171            assert_param(IS_CAN_ALL_PERIPH(CANx));
    172           
    173            if (CANx == CAN1)
    174            {
    175              /* Enable CAN1 reset state */
    176              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
    177              /* Release CAN1 from reset state */
    178              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
    179            }
    180            else
    181            {  
    182              /* Enable CAN2 reset state */
    183              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
    184              /* Release CAN2 from reset state */
    185              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
    186            }
    187          }
    188          
    189          /**
    190            * @brief  Initializes the CAN peripheral according to the specified
    191            *         parameters in the CAN_InitStruct.
    192            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    193            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that contains
    194            *         the configuration information for the CAN peripheral.
    195            * @retval Constant indicates initialization succeed which will be 
    196            *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
    197            */
    198          uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
    199          {
    200            uint8_t InitStatus = CAN_InitStatus_Failed;
    201            uint32_t wait_ack = 0x00000000;
    202            /* Check the parameters */
    203            assert_param(IS_CAN_ALL_PERIPH(CANx));
    204            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    205            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    206            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    207            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    208            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    209            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    210            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    211            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    212            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    213            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    214            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    215          
    216            /* Exit from sleep mode */
    217            CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
    218          
    219            /* Request initialisation */
    220            CANx->MCR |= CAN_MCR_INRQ ;
    221          
    222            /* Wait the acknowledge */
    223            while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    224            {
    225              wait_ack++;
    226            }
    227          
    228            /* Check acknowledge */
    229            if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
    230            {
    231              InitStatus = CAN_InitStatus_Failed;
    232            }
    233            else 
    234            {
    235              /* Set the time triggered communication mode */
    236              if (CAN_InitStruct->CAN_TTCM == ENABLE)
    237              {
    238                CANx->MCR |= CAN_MCR_TTCM;
    239              }
    240              else
    241              {
    242                CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
    243              }
    244          
    245              /* Set the automatic bus-off management */
    246              if (CAN_InitStruct->CAN_ABOM == ENABLE)
    247              {
    248                CANx->MCR |= CAN_MCR_ABOM;
    249              }
    250              else
    251              {
    252                CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
    253              }
    254          
    255              /* Set the automatic wake-up mode */
    256              if (CAN_InitStruct->CAN_AWUM == ENABLE)
    257              {
    258                CANx->MCR |= CAN_MCR_AWUM;
    259              }
    260              else
    261              {
    262                CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
    263              }
    264          
    265              /* Set the no automatic retransmission */
    266              if (CAN_InitStruct->CAN_NART == ENABLE)
    267              {
    268                CANx->MCR |= CAN_MCR_NART;
    269              }
    270              else
    271              {
    272                CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
    273              }
    274          
    275              /* Set the receive FIFO locked mode */
    276              if (CAN_InitStruct->CAN_RFLM == ENABLE)
    277              {
    278                CANx->MCR |= CAN_MCR_RFLM;
    279              }
    280              else
    281              {
    282                CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
    283              }
    284          
    285              /* Set the transmit FIFO priority */
    286              if (CAN_InitStruct->CAN_TXFP == ENABLE)
    287              {
    288                CANx->MCR |= CAN_MCR_TXFP;
    289              }
    290              else
    291              {
    292                CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    293              }
    294          
    295              /* Set the bit timing register */
    296              CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
    297                          ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
    298                          ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
    299                          ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
    300                         ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
    301          
    302              /* Request leave initialisation */
    303              CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
    304          
    305             /* Wait the acknowledge */
    306             wait_ack = 0;
    307          
    308             while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    309             {
    310               wait_ack++;
    311             }
    312          
    313              /* ...and check acknowledged */
    314              if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
    315              {
    316                InitStatus = CAN_InitStatus_Failed;
    317              }
    318              else
    319              {
    320                InitStatus = CAN_InitStatus_Success ;
    321              }
    322            }
    323          
    324            /* At this step, return the status of initialization */
    325            return InitStatus;
    326          }
    327          
    328          /**
    329            * @brief  Configures the CAN reception filter according to the specified
    330            *         parameters in the CAN_FilterInitStruct.
    331            * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
    332            *         contains the configuration information.
    333            * @retval None
    334            */
    335          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    336          {
    337            uint32_t filter_number_bit_pos = 0;
    338            /* Check the parameters */
    339            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    340            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    341            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    342            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    343            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    344          
    345            filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
    346          
    347            /* Initialisation mode for the filter */
    348            CAN1->FMR |= FMR_FINIT;
    349          
    350            /* Filter Deactivation */
    351            CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
    352          
    353            /* Filter Scale */
    354            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
    355            {
    356              /* 16-bit scale for the filter */
    357              CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
    358          
    359              /* First 16-bit identifier and First 16-bit mask */
    360              /* Or First 16-bit identifier and Second 16-bit identifier */
    361              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    362                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    363                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    364          
    365              /* Second 16-bit identifier and Second 16-bit mask */
    366              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    367              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    368                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    369                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
    370            }
    371          
    372            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
    373            {
    374              /* 32-bit scale for the filter */
    375              CAN1->FS1R |= filter_number_bit_pos;
    376              /* 32-bit identifier or First 32-bit identifier */
    377              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    378                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    379                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    380              /* 32-bit mask or Second 32-bit identifier */
    381              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    382                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    383                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
    384            }
    385          
    386            /* Filter Mode */
    387            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
    388            {
    389              /*Id/Mask mode for the filter*/
    390              CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
    391            }
    392            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    393            {
    394              /*Identifier list mode for the filter*/
    395              CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
    396            }
    397          
    398            /* Filter FIFO assignment */
    399            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
    400            {
    401              /* FIFO 0 assignation for the filter */
    402              CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
    403            }
    404          
    405            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
    406            {
    407              /* FIFO 1 assignation for the filter */
    408              CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
    409            }
    410            
    411            /* Filter activation */
    412            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
    413            {
    414              CAN1->FA1R |= filter_number_bit_pos;
    415            }
    416          
    417            /* Leave the initialisation mode for the filter */
    418            CAN1->FMR &= ~FMR_FINIT;
    419          }
    420          
    421          /**
    422            * @brief  Fills each CAN_InitStruct member with its default value.
    423            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which ill be initialized.
    424            * @retval None
    425            */
    426          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    427          {
    428            /* Reset CAN init structure parameters values */
    429            
    430            /* Initialize the time triggered communication mode */
    431            CAN_InitStruct->CAN_TTCM = DISABLE;
    432            
    433            /* Initialize the automatic bus-off management */
    434            CAN_InitStruct->CAN_ABOM = DISABLE;
    435            
    436            /* Initialize the automatic wake-up mode */
    437            CAN_InitStruct->CAN_AWUM = DISABLE;
    438            
    439            /* Initialize the no automatic retransmission */
    440            CAN_InitStruct->CAN_NART = DISABLE;
    441            
    442            /* Initialize the receive FIFO locked mode */
    443            CAN_InitStruct->CAN_RFLM = DISABLE;
    444            
    445            /* Initialize the transmit FIFO priority */
    446            CAN_InitStruct->CAN_TXFP = DISABLE;
    447            
    448            /* Initialize the CAN_Mode member */
    449            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
    450            
    451            /* Initialize the CAN_SJW member */
    452            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
    453            
    454            /* Initialize the CAN_BS1 member */
    455            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
    456            
    457            /* Initialize the CAN_BS2 member */
    458            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
    459            
    460            /* Initialize the CAN_Prescaler member */
    461            CAN_InitStruct->CAN_Prescaler = 1;
    462          }
    463          
    464          /**
    465            * @brief  Select the start bank filter for slave CAN.
    466            * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
    467            * @retval None
    468            */
    469          void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
    470          {
    471            /* Check the parameters */
    472            assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
    473            
    474            /* Enter Initialisation mode for the filter */
    475            CAN1->FMR |= FMR_FINIT;
    476            
    477            /* Select the start slave bank */
    478            CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
    479            CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
    480            
    481            /* Leave Initialisation mode for the filter */
    482            CAN1->FMR &= ~FMR_FINIT;
    483          }
    484          
    485          /**
    486            * @brief  Enables or disables the DBG Freeze for CAN.
    487            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    488            * @param  NewState: new state of the CAN peripheral. 
    489            *          This parameter can be: ENABLE (CAN reception/transmission is frozen
    490            *          during debug. Reception FIFOs can still be accessed/controlled normally) 
    491            *          or DISABLE (CAN is working during debug).
    492            * @retval None
    493            */
    494          void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
    495          {
    496            /* Check the parameters */
    497            assert_param(IS_CAN_ALL_PERIPH(CANx));
    498            assert_param(IS_FUNCTIONAL_STATE(NewState));
    499            
    500            if (NewState != DISABLE)
    501            {
    502              /* Enable Debug Freeze  */
    503              CANx->MCR |= MCR_DBF;
    504            }
    505            else
    506            {
    507              /* Disable Debug Freeze */
    508              CANx->MCR &= ~MCR_DBF;
    509            }
    510          }
    511          
    512          
    513          /**
    514            * @brief  Enables or disables the CAN Time TriggerOperation communication mode.
    515            * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
    516            *         sent over the CAN bus.  
    517            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    518            * @param  NewState: Mode new state. This parameter can be: ENABLE or DISABLE.
    519            *         When enabled, Time stamp (TIME[15:0]) value is  sent in the last two
    520            *         data bytes of the 8-byte message: TIME[7:0] in data byte 6 and TIME[15:8] 
    521            *         in data byte 7. 
    522            * @retval None
    523            */
    524          void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
    525          {
    526            /* Check the parameters */
    527            assert_param(IS_CAN_ALL_PERIPH(CANx));
    528            assert_param(IS_FUNCTIONAL_STATE(NewState));
    529            if (NewState != DISABLE)
    530            {
    531              /* Enable the TTCM mode */
    532              CANx->MCR |= CAN_MCR_TTCM;
    533          
    534              /* Set TGT bits */
    535              CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
    536              CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
    537              CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
    538            }
    539            else
    540            {
    541              /* Disable the TTCM mode */
    542              CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
    543          
    544              /* Reset TGT bits */
    545              CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
    546              CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
    547              CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
    548            }
    549          }
    550          /**
    551            * @}
    552            */
    553          
    554          
    555          /** @defgroup CAN_Group2 CAN Frames Transmission functions
    556           *  @brief    CAN Frames Transmission functions 
    557           *
    558          @verbatim    
    559           ===============================================================================
    560                                CAN Frames Transmission functions
    561           ===============================================================================  
    562            This section provides functions allowing to 
    563             - Initiate and transmit a CAN frame message (if there is an empty mailbox).
    564             - Check the transmission status of a CAN Frame
    565             - Cancel a transmit request
    566             
    567          @endverbatim
    568            * @{
    569            */
    570          
    571          /**
    572            * @brief  Initiates and transmits a CAN frame message.
    573            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    574            * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
    575            * @retval The number of the mailbox that is used for transmission or
    576            *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
    577            */
    578          uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
    579          {
    580            uint8_t transmit_mailbox = 0;
    581            /* Check the parameters */
    582            assert_param(IS_CAN_ALL_PERIPH(CANx));
    583            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    584            assert_param(IS_CAN_RTR(TxMessage->RTR));
    585            assert_param(IS_CAN_DLC(TxMessage->DLC));
    586          
    587            /* Select one empty transmit mailbox */
    588            if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
    589            {
    590              transmit_mailbox = 0;
    591            }
    592            else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
    593            {
    594              transmit_mailbox = 1;
    595            }
    596            else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
    597            {
    598              transmit_mailbox = 2;
    599            }
    600            else
    601            {
    602              transmit_mailbox = CAN_TxStatus_NoMailBox;
    603            }
    604          
    605            if (transmit_mailbox != CAN_TxStatus_NoMailBox)
    606            {
    607              /* Set up the Id */
    608              CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
    609              if (TxMessage->IDE == CAN_Id_Standard)
    610              {
    611                assert_param(IS_CAN_STDID(TxMessage->StdId));  
    612                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
    613                                                            TxMessage->RTR);
    614              }
    615              else
    616              {
    617                assert_param(IS_CAN_EXTID(TxMessage->ExtId));
    618                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
    619                                                            TxMessage->IDE | \
    620                                                            TxMessage->RTR);
    621              }
    622              
    623              /* Set up the DLC */
    624              TxMessage->DLC &= (uint8_t)0x0000000F;
    625              CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    626              CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
    627          
    628              /* Set up the data field */
    629              CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
    630                                                       ((uint32_t)TxMessage->Data[2] << 16) |
    631                                                       ((uint32_t)TxMessage->Data[1] << 8) | 
    632                                                       ((uint32_t)TxMessage->Data[0]));
    633              CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
    634                                                       ((uint32_t)TxMessage->Data[6] << 16) |
    635                                                       ((uint32_t)TxMessage->Data[5] << 8) |
    636                                                       ((uint32_t)TxMessage->Data[4]));
    637              /* Request transmission */
    638              CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
    639            }
    640            return transmit_mailbox;
    641          }
    642          
    643          /**
    644            * @brief  Checks the transmission status of a CAN Frame.
    645            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    646            * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
    647            * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, 
    648            *         CAN_TxStatus_Failed in an other case.
    649            */
    650          uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
    651          {
    652            uint32_t state = 0;
    653          
    654            /* Check the parameters */
    655            assert_param(IS_CAN_ALL_PERIPH(CANx));
    656            assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    657           
    658            switch (TransmitMailbox)
    659            {
    660              case (CAN_TXMAILBOX_0): 
    661                state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
    662                break;
    663              case (CAN_TXMAILBOX_1): 
    664                state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
    665                break;
    666              case (CAN_TXMAILBOX_2): 
    667                state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
    668                break;
    669              default:
    670                state = CAN_TxStatus_Failed;
    671                break;
    672            }
    673            switch (state)
    674            {
    675                /* transmit pending  */
    676              case (0x0): state = CAN_TxStatus_Pending;
    677                break;
    678                /* transmit failed  */
    679               case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
    680                break;
    681               case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
    682                break;
    683               case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
    684                break;
    685                /* transmit succeeded  */
    686              case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
    687                break;
    688              case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
    689                break;
    690              case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
    691                break;
    692              default: state = CAN_TxStatus_Failed;
    693                break;
    694            }
    695            return (uint8_t) state;
    696          }
    697          
    698          /**
    699            * @brief  Cancels a transmit request.
    700            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    701            * @param  Mailbox: Mailbox number.
    702            * @retval None
    703            */
    704          void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
    705          {
    706            /* Check the parameters */
    707            assert_param(IS_CAN_ALL_PERIPH(CANx));
    708            assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    709            /* abort transmission */
    710            switch (Mailbox)
    711            {
    712              case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
    713                break;
    714              case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
    715                break;
    716              case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
    717                break;
    718              default:
    719                break;
    720            }
    721          }
    722          /**
    723            * @}
    724            */
    725          
    726          
    727          /** @defgroup CAN_Group3 CAN Frames Reception functions
    728           *  @brief    CAN Frames Reception functions 
    729           *
    730          @verbatim    
    731           ===============================================================================
    732                                CAN Frames Reception functions
    733           ===============================================================================  
    734            This section provides functions allowing to 
    735             -  Receive a correct CAN frame
    736             -  Release a specified receive FIFO (2 FIFOs are available)
    737             -  Return the number of the pending received CAN frames
    738             
    739          @endverbatim
    740            * @{
    741            */
    742          
    743          /**
    744            * @brief  Receives a correct CAN frame.
    745            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    746            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    747            * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
    748            *         CAN DLC, CAN data and FMI number.
    749            * @retval None
    750            */
    751          void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
    752          {
    753            /* Check the parameters */
    754            assert_param(IS_CAN_ALL_PERIPH(CANx));
    755            assert_param(IS_CAN_FIFO(FIFONumber));
    756            /* Get the Id */
    757            RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
    758            if (RxMessage->IDE == CAN_Id_Standard)
    759            {
    760              RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
    761            }
    762            else
    763            {
    764              RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
    765            }
    766            
    767            RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
    768            /* Get the DLC */
    769            RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
    770            /* Get the FMI */
    771            RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
    772            /* Get the data field */
    773            RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
    774            RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
    775            RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
    776            RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
    777            RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
    778            RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
    779            RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
    780            RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
    781            /* Release the FIFO */
    782            /* Release FIFO0 */
    783            if (FIFONumber == CAN_FIFO0)
    784            {
    785              CANx->RF0R |= CAN_RF0R_RFOM0;
    786            }
    787            /* Release FIFO1 */
    788            else /* FIFONumber == CAN_FIFO1 */
    789            {
    790              CANx->RF1R |= CAN_RF1R_RFOM1;
    791            }
    792          }
    793          
    794          /**
    795            * @brief  Releases the specified receive FIFO.
    796            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    797            * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    798            * @retval None
    799            */
    800          void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
    801          {
    802            /* Check the parameters */
    803            assert_param(IS_CAN_ALL_PERIPH(CANx));
    804            assert_param(IS_CAN_FIFO(FIFONumber));
    805            /* Release FIFO0 */
    806            if (FIFONumber == CAN_FIFO0)
    807            {
    808              CANx->RF0R |= CAN_RF0R_RFOM0;
    809            }
    810            /* Release FIFO1 */
    811            else /* FIFONumber == CAN_FIFO1 */
    812            {
    813              CANx->RF1R |= CAN_RF1R_RFOM1;
    814            }
    815          }
    816          
    817          /**
    818            * @brief  Returns the number of pending received messages.
    819            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    820            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    821            * @retval NbMessage : which is the number of pending message.
    822            */
    823          uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
    824          {
    825            uint8_t message_pending=0;
    826            /* Check the parameters */
    827            assert_param(IS_CAN_ALL_PERIPH(CANx));
    828            assert_param(IS_CAN_FIFO(FIFONumber));
    829            if (FIFONumber == CAN_FIFO0)
    830            {
    831              message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
    832            }
    833            else if (FIFONumber == CAN_FIFO1)
    834            {
    835              message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
    836            }
    837            else
    838            {
    839              message_pending = 0;
    840            }
    841            return message_pending;
    842          }
    843          /**
    844            * @}
    845            */
    846          
    847          
    848          /** @defgroup CAN_Group4 CAN Operation modes functions
    849           *  @brief    CAN Operation modes functions 
    850           *
    851          @verbatim    
    852           ===============================================================================
    853                                CAN Operation modes functions
    854           ===============================================================================  
    855            This section provides functions allowing to select the CAN Operation modes
    856            - sleep mode
    857            - normal mode 
    858            - initialization mode
    859             
    860          @endverbatim
    861            * @{
    862            */
    863            
    864            
    865          /**
    866            * @brief  Selects the CAN Operation mode.
    867            * @param  CAN_OperatingMode: CAN Operating Mode.
    868            *         This parameter can be one of @ref CAN_OperatingMode_TypeDef enumeration.
    869            * @retval status of the requested mode which can be 
    870            *         - CAN_ModeStatus_Failed:  CAN failed entering the specific mode 
    871            *         - CAN_ModeStatus_Success: CAN Succeed entering the specific mode 
    872            */
    873          uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
    874          {
    875            uint8_t status = CAN_ModeStatus_Failed;
    876            
    877            /* Timeout for INAK or also for SLAK bits*/
    878            uint32_t timeout = INAK_TIMEOUT; 
    879          
    880            /* Check the parameters */
    881            assert_param(IS_CAN_ALL_PERIPH(CANx));
    882            assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
    883          
    884            if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
    885            {
    886              /* Request initialisation */
    887              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
    888          
    889              /* Wait the acknowledge */
    890              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
    891              {
    892                timeout--;
    893              }
    894              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
    895              {
    896                status = CAN_ModeStatus_Failed;
    897              }
    898              else
    899              {
    900                status = CAN_ModeStatus_Success;
    901              }
    902            }
    903            else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
    904            {
    905              /* Request leave initialisation and sleep mode  and enter Normal mode */
    906              CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
    907          
    908              /* Wait the acknowledge */
    909              while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
    910              {
    911                timeout--;
    912              }
    913              if ((CANx->MSR & CAN_MODE_MASK) != 0)
    914              {
    915                status = CAN_ModeStatus_Failed;
    916              }
    917              else
    918              {
    919                status = CAN_ModeStatus_Success;
    920              }
    921            }
    922            else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
    923            {
    924              /* Request Sleep mode */
    925              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
    926          
    927              /* Wait the acknowledge */
    928              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
    929              {
    930                timeout--;
    931              }
    932              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
    933              {
    934                status = CAN_ModeStatus_Failed;
    935              }
    936              else
    937              {
    938                status = CAN_ModeStatus_Success;
    939              }
    940            }
    941            else
    942            {
    943              status = CAN_ModeStatus_Failed;
    944            }
    945          
    946            return  (uint8_t) status;
    947          }
    948          
    949          /**
    950            * @brief  Enters the Sleep (low power) mode.
    951            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    952            * @retval CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed otherwise.
    953            */
    954          uint8_t CAN_Sleep(CAN_TypeDef* CANx)
    955          {
    956            uint8_t sleepstatus = CAN_Sleep_Failed;
    957            
    958            /* Check the parameters */
    959            assert_param(IS_CAN_ALL_PERIPH(CANx));
    960              
    961            /* Request Sleep mode */
    962             CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
    963             
    964            /* Sleep mode status */
    965            if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
    966            {
    967              /* Sleep mode not entered */
    968              sleepstatus =  CAN_Sleep_Ok;
    969            }
    970            /* return sleep mode status */
    971             return (uint8_t)sleepstatus;
    972          }
    973          
    974          /**
    975            * @brief  Wakes up the CAN peripheral from sleep mode .
    976            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    977            * @retval CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed otherwise.
    978            */
    979          uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
    980          {
    981            uint32_t wait_slak = SLAK_TIMEOUT;
    982            uint8_t wakeupstatus = CAN_WakeUp_Failed;
    983            
    984            /* Check the parameters */
    985            assert_param(IS_CAN_ALL_PERIPH(CANx));
    986              
    987            /* Wake up request */
    988            CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
    989              
    990            /* Sleep mode status */
    991            while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
    992            {
    993             wait_slak--;
    994            }
    995            if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
    996            {
    997             /* wake up done : Sleep mode exited */
    998              wakeupstatus = CAN_WakeUp_Ok;
    999            }
   1000            /* return wakeup status */
   1001            return (uint8_t)wakeupstatus;
   1002          }
   1003          /**
   1004            * @}
   1005            */
   1006          
   1007          
   1008          /** @defgroup CAN_Group5 CAN Bus Error management functions
   1009           *  @brief    CAN Bus Error management functions 
   1010           *
   1011          @verbatim    
   1012           ===============================================================================
   1013                                CAN Bus Error management functions
   1014           ===============================================================================  
   1015            This section provides functions allowing to 
   1016             -  Return the CANx's last error code (LEC)
   1017             -  Return the CANx Receive Error Counter (REC)
   1018             -  Return the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1019             
   1020             @note If TEC is greater than 255, The CAN is in bus-off state.
   1021             @note if REC or TEC are greater than 96, an Error warning flag occurs.
   1022             @note if REC or TEC are greater than 127, an Error Passive Flag occurs.
   1023                                  
   1024          @endverbatim
   1025            * @{
   1026            */
   1027            
   1028          /**
   1029            * @brief  Returns the CANx's last error code (LEC).
   1030            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
   1031            * @retval Error code: 
   1032            *          - CAN_ERRORCODE_NoErr: No Error  
   1033            *          - CAN_ERRORCODE_StuffErr: Stuff Error
   1034            *          - CAN_ERRORCODE_FormErr: Form Error
   1035            *          - CAN_ERRORCODE_ACKErr : Acknowledgment Error
   1036            *          - CAN_ERRORCODE_BitRecessiveErr: Bit Recessive Error
   1037            *          - CAN_ERRORCODE_BitDominantErr: Bit Dominant Error
   1038            *          - CAN_ERRORCODE_CRCErr: CRC Error
   1039            *          - CAN_ERRORCODE_SoftwareSetErr: Software Set Error  
   1040            */
   1041          uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
   1042          {
   1043            uint8_t errorcode=0;
   1044            
   1045            /* Check the parameters */
   1046            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1047            
   1048            /* Get the error code*/
   1049            errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
   1050            
   1051            /* Return the error code*/
   1052            return errorcode;
   1053          }
   1054          
   1055          /**
   1056            * @brief  Returns the CANx Receive Error Counter (REC).
   1057            * @note   In case of an error during reception, this counter is incremented 
   1058            *         by 1 or by 8 depending on the error condition as defined by the CAN 
   1059            *         standard. After every successful reception, the counter is 
   1060            *         decremented by 1 or reset to 120 if its value was higher than 128. 
   1061            *         When the counter value exceeds 127, the CAN controller enters the 
   1062            *         error passive state.  
   1063            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
   1064            * @retval CAN Receive Error Counter. 
   1065            */
   1066          uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
   1067          {
   1068            uint8_t counter=0;
   1069            
   1070            /* Check the parameters */
   1071            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1072            
   1073            /* Get the Receive Error Counter*/
   1074            counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
   1075            
   1076            /* Return the Receive Error Counter*/
   1077            return counter;
   1078          }
   1079          
   1080          
   1081          /**
   1082            * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1083            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1084            * @retval LSB of the 9-bit CAN Transmit Error Counter. 
   1085            */
   1086          uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
   1087          {
   1088            uint8_t counter=0;
   1089            
   1090            /* Check the parameters */
   1091            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1092            
   1093            /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1094            counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
   1095            
   1096            /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1097            return counter;
   1098          }
   1099          /**
   1100            * @}
   1101            */
   1102          
   1103          /** @defgroup CAN_Group6 Interrupts and flags management functions
   1104           *  @brief   Interrupts and flags management functions
   1105           *
   1106          @verbatim   
   1107           ===============================================================================
   1108                             Interrupts and flags management functions
   1109           ===============================================================================  
   1110          
   1111            This section provides functions allowing to configure the CAN Interrupts and 
   1112            to get the status and clear flags and Interrupts pending bits.
   1113            
   1114            The CAN provides 14 Interrupts sources and 15 Flags:
   1115          
   1116            ===============  
   1117                Flags :
   1118            ===============
   1119            The 15 flags can be divided on 4 groups: 
   1120          
   1121             A. Transmit Flags
   1122            -----------------------
   1123                  CAN_FLAG_RQCP0, 
   1124                  CAN_FLAG_RQCP1, 
   1125                  CAN_FLAG_RQCP2  : Request completed MailBoxes 0, 1 and 2  Flags
   1126                                    Set when when the last request (transmit or abort) has 
   1127                                    been performed. 
   1128          
   1129            B. Receive Flags
   1130            -----------------------
   1131          
   1132                  CAN_FLAG_FMP0,
   1133                  CAN_FLAG_FMP1   : FIFO 0 and 1 Message Pending Flags 
   1134                                    set to signal that messages are pending in the receive 
   1135                                    FIFO.
   1136                                    These Flags are cleared only by hardware. 
   1137          
   1138                  CAN_FLAG_FF0,
   1139                  CAN_FLAG_FF1    : FIFO 0 and 1 Full Flags
   1140                                    set when three messages are stored in the selected 
   1141                                    FIFO.                        
   1142          
   1143                  CAN_FLAG_FOV0              
   1144                  CAN_FLAG_FOV1   : FIFO 0 and 1 Overrun Flags
   1145                                    set when a new message has been received and passed 
   1146                                    the filter while the FIFO was full.         
   1147          
   1148            C. Operating Mode Flags
   1149            ----------------------- 
   1150                  CAN_FLAG_WKU    : Wake up Flag
   1151                                    set to signal that a SOF bit has been detected while 
   1152                                    the CAN hardware was in Sleep mode. 
   1153                  
   1154                  CAN_FLAG_SLAK   : Sleep acknowledge Flag
   1155                                    Set to signal that the CAN has entered Sleep Mode. 
   1156              
   1157            D. Error Flags
   1158            ----------------------- 
   1159                  CAN_FLAG_EWG    : Error Warning Flag
   1160                                    Set when the warning limit has been reached (Receive 
   1161                                    Error Counter or Transmit Error Counter greater than 96). 
   1162                                    This Flag is cleared only by hardware.
   1163                                      
   1164                  CAN_FLAG_EPV    : Error Passive Flag
   1165                                    Set when the Error Passive limit has been reached 
   1166                                    (Receive Error Counter or Transmit Error Counter 
   1167                                    greater than 127).
   1168                                    This Flag is cleared only by hardware.
   1169                                       
   1170                  CAN_FLAG_BOF    : Bus-Off Flag
   1171                                    set when CAN enters the bus-off state. The bus-off 
   1172                                    state is entered on TEC overflow, greater than 255.
   1173                                    This Flag is cleared only by hardware.
   1174                                             
   1175                  CAN_FLAG_LEC    : Last error code Flag
   1176                                    set If a message has been transferred (reception or
   1177                                    transmission) with error, and the error code is hold.              
   1178                                    
   1179            ===============  
   1180             Interrupts :
   1181            ===============
   1182            The 14 interrupts can be divided on 4 groups: 
   1183            
   1184             A. Transmit interrupt
   1185            -----------------------   
   1186                    CAN_IT_TME   :  Transmit mailbox empty Interrupt
   1187                                    if enabled, this interrupt source is pending when 
   1188                                    no transmit request are pending for Tx mailboxes.      
   1189          
   1190             B. Receive Interrupts
   1191            -----------------------          
   1192                  CAN_IT_FMP0,
   1193                  CAN_IT_FMP1    :  FIFO 0 and FIFO1 message pending Interrupts
   1194                                    if enabled, these interrupt sources are pending when 
   1195                                    messages are pending in the receive FIFO.
   1196                                    The corresponding interrupt pending bits are cleared 
   1197                                    only by hardware.
   1198                          
   1199                  CAN_IT_FF0,              
   1200                  CAN_IT_FF1     :  FIFO 0 and FIFO1 full Interrupts
   1201                                    if enabled, these interrupt sources are pending when
   1202                                    three messages are stored in the selected FIFO.
   1203                  
   1204                  CAN_IT_FOV0,        
   1205                  CAN_IT_FOV1    :  FIFO 0 and FIFO1 overrun Interrupts        
   1206                                    if enabled, these interrupt sources are pending when
   1207                                    a new message has been received and passed the filter
   1208                                    while the FIFO was full.
   1209          
   1210             C. Operating Mode Interrupts
   1211            -------------------------------          
   1212                  CAN_IT_WKU     :  Wake-up Interrupt
   1213                                    if enabled, this interrupt source is pending when 
   1214                                    a SOF bit has been detected while the CAN hardware was 
   1215                                    in Sleep mode.
   1216                                            
   1217                  CAN_IT_SLK     :  Sleep acknowledge Interrupt
   1218                                    if enabled, this interrupt source is pending when 
   1219                                    the CAN has entered Sleep Mode.       
   1220          
   1221             D. Error Interrupts 
   1222            -----------------------         
   1223                  CAN_IT_EWG     :  Error warning Interrupt 
   1224                                    if enabled, this interrupt source is pending when
   1225                                    the warning limit has been reached (Receive Error 
   1226                                    Counter or Transmit Error Counter=96). 
   1227                                         
   1228                  CAN_IT_EPV     :  Error passive Interrupt        
   1229                                    if enabled, this interrupt source is pending when
   1230                                    the Error Passive limit has been reached (Receive 
   1231                                    Error Counter or Transmit Error Counter>127).
   1232                                    
   1233                  CAN_IT_BOF     :  Bus-off Interrupt
   1234                                    if enabled, this interrupt source is pending when
   1235                                    CAN enters the bus-off state. The bus-off state is 
   1236                                    entered on TEC overflow, greater than 255.
   1237                                    This Flag is cleared only by hardware.
   1238                                            
   1239                  CAN_IT_LEC     :  Last error code Interrupt        
   1240                                    if enabled, this interrupt source is pending  when
   1241                                    a message has been transferred (reception or
   1242                                    transmission) with error, and the error code is hold.
   1243                                    
   1244                  CAN_IT_ERR     :  Error Interrupt
   1245                                    if enabled, this interrupt source is pending when 
   1246                                    an error condition is pending.      
   1247                                
   1248          
   1249            Managing the CAN controller events :
   1250            ------------------------------------ 
   1251            The user should identify which mode will be used in his application to manage 
   1252            the CAN controller events: Polling mode or Interrupt mode.
   1253            
   1254            1.  In the Polling Mode it is advised to use the following functions:
   1255                - CAN_GetFlagStatus() : to check if flags events occur. 
   1256                - CAN_ClearFlag()     : to clear the flags events.
   1257            
   1258          
   1259            
   1260            2.  In the Interrupt Mode it is advised to use the following functions:
   1261                - CAN_ITConfig()       : to enable or disable the interrupt source.
   1262                - CAN_GetITStatus()    : to check if Interrupt occurs.
   1263                - CAN_ClearITPendingBit() : to clear the Interrupt pending Bit (corresponding Flag).
   1264                @note  This function has no impact on CAN_IT_FMP0 and CAN_IT_FMP1 Interrupts 
   1265                       pending bits since there are cleared only by hardware. 
   1266            
   1267          @endverbatim
   1268            * @{
   1269            */ 
   1270          /**
   1271            * @brief  Enables or disables the specified CANx interrupts.
   1272            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1273            * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
   1274            *          This parameter can be: 
   1275            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1276            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1277            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1278            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1279            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1280            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1281            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1282            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1283            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1284            *            @arg CAN_IT_EWG: Error warning Interrupt
   1285            *            @arg CAN_IT_EPV: Error passive Interrupt
   1286            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1287            *            @arg CAN_IT_LEC: Last error code Interrupt
   1288            *            @arg CAN_IT_ERR: Error Interrupt
   1289            * @param  NewState: new state of the CAN interrupts.
   1290            *          This parameter can be: ENABLE or DISABLE.
   1291            * @retval None
   1292            */
   1293          void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
   1294          {
   1295            /* Check the parameters */
   1296            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1297            assert_param(IS_CAN_IT(CAN_IT));
   1298            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1299          
   1300            if (NewState != DISABLE)
   1301            {
   1302              /* Enable the selected CANx interrupt */
   1303              CANx->IER |= CAN_IT;
   1304            }
   1305            else
   1306            {
   1307              /* Disable the selected CANx interrupt */
   1308              CANx->IER &= ~CAN_IT;
   1309            }
   1310          }
   1311          /**
   1312            * @brief  Checks whether the specified CAN flag is set or not.
   1313            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1314            * @param  CAN_FLAG: specifies the flag to check.
   1315            *          This parameter can be one of the following values:
   1316            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1317            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1318            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag
   1319            *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag   
   1320            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1321            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag 
   1322            *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag   
   1323            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1324            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1325            *            @arg CAN_FLAG_WKU: Wake up Flag
   1326            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag 
   1327            *            @arg CAN_FLAG_EWG: Error Warning Flag
   1328            *            @arg CAN_FLAG_EPV: Error Passive Flag  
   1329            *            @arg CAN_FLAG_BOF: Bus-Off Flag    
   1330            *            @arg CAN_FLAG_LEC: Last error code Flag      
   1331            * @retval The new state of CAN_FLAG (SET or RESET).
   1332            */
   1333          FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1334          {
   1335            FlagStatus bitstatus = RESET;
   1336            
   1337            /* Check the parameters */
   1338            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1339            assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
   1340            
   1341          
   1342            if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
   1343            { 
   1344              /* Check the status of the specified CAN flag */
   1345              if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1346              { 
   1347                /* CAN_FLAG is set */
   1348                bitstatus = SET;
   1349              }
   1350              else
   1351              { 
   1352                /* CAN_FLAG is reset */
   1353                bitstatus = RESET;
   1354              }
   1355            }
   1356            else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
   1357            { 
   1358              /* Check the status of the specified CAN flag */
   1359              if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1360              { 
   1361                /* CAN_FLAG is set */
   1362                bitstatus = SET;
   1363              }
   1364              else
   1365              { 
   1366                /* CAN_FLAG is reset */
   1367                bitstatus = RESET;
   1368              }
   1369            }
   1370            else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
   1371            { 
   1372              /* Check the status of the specified CAN flag */
   1373              if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1374              { 
   1375                /* CAN_FLAG is set */
   1376                bitstatus = SET;
   1377              }
   1378              else
   1379              { 
   1380                /* CAN_FLAG is reset */
   1381                bitstatus = RESET;
   1382              }
   1383            }
   1384            else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
   1385            { 
   1386              /* Check the status of the specified CAN flag */
   1387              if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1388              { 
   1389                /* CAN_FLAG is set */
   1390                bitstatus = SET;
   1391              }
   1392              else
   1393              { 
   1394                /* CAN_FLAG is reset */
   1395                bitstatus = RESET;
   1396              }
   1397            }
   1398            else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
   1399            { 
   1400              /* Check the status of the specified CAN flag */
   1401              if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1402              { 
   1403                /* CAN_FLAG is set */
   1404                bitstatus = SET;
   1405              }
   1406              else
   1407              { 
   1408                /* CAN_FLAG is reset */
   1409                bitstatus = RESET;
   1410              }
   1411            }
   1412            /* Return the CAN_FLAG status */
   1413            return  bitstatus;
   1414          }
   1415          
   1416          /**
   1417            * @brief  Clears the CAN's pending flags.
   1418            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1419            * @param  CAN_FLAG: specifies the flag to clear.
   1420            *          This parameter can be one of the following values:
   1421            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1422            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1423            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag 
   1424            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1425            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag  
   1426            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1427            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1428            *            @arg CAN_FLAG_WKU: Wake up Flag
   1429            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag    
   1430            *            @arg CAN_FLAG_LEC: Last error code Flag        
   1431            * @retval None
   1432            */
   1433          void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1434          {
   1435            uint32_t flagtmp=0;
   1436            /* Check the parameters */
   1437            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1438            assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
   1439            
   1440            if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
   1441            {
   1442              /* Clear the selected CAN flags */
   1443              CANx->ESR = (uint32_t)RESET;
   1444            }
   1445            else /* MSR or TSR or RF0R or RF1R */
   1446            {
   1447              flagtmp = CAN_FLAG & 0x000FFFFF;
   1448          
   1449              if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
   1450              {
   1451                /* Receive Flags */
   1452                CANx->RF0R = (uint32_t)(flagtmp);
   1453              }
   1454              else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
   1455              {
   1456                /* Receive Flags */
   1457                CANx->RF1R = (uint32_t)(flagtmp);
   1458              }
   1459              else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
   1460              {
   1461                /* Transmit Flags */
   1462                CANx->TSR = (uint32_t)(flagtmp);
   1463              }
   1464              else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
   1465              {
   1466                /* Operating mode Flags */
   1467                CANx->MSR = (uint32_t)(flagtmp);
   1468              }
   1469            }
   1470          }
   1471          
   1472          /**
   1473            * @brief  Checks whether the specified CANx interrupt has occurred or not.
   1474            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1475            * @param  CAN_IT: specifies the CAN interrupt source to check.
   1476            *          This parameter can be one of the following values:
   1477            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1478            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1479            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1480            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1481            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1482            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1483            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1484            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1485            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1486            *            @arg CAN_IT_EWG: Error warning Interrupt
   1487            *            @arg CAN_IT_EPV: Error passive Interrupt
   1488            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1489            *            @arg CAN_IT_LEC: Last error code Interrupt
   1490            *            @arg CAN_IT_ERR: Error Interrupt
   1491            * @retval The current state of CAN_IT (SET or RESET).
   1492            */
   1493          ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1494          {
   1495            ITStatus itstatus = RESET;
   1496            /* Check the parameters */
   1497            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1498            assert_param(IS_CAN_IT(CAN_IT));
   1499            
   1500            /* check the interrupt enable bit */
   1501           if((CANx->IER & CAN_IT) != RESET)
   1502           {
   1503             /* in case the Interrupt is enabled, .... */
   1504              switch (CAN_IT)
   1505              {
   1506                case CAN_IT_TME:
   1507                  /* Check CAN_TSR_RQCPx bits */
   1508                  itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
   1509                  break;
   1510                case CAN_IT_FMP0:
   1511                  /* Check CAN_RF0R_FMP0 bit */
   1512                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
   1513                  break;
   1514                case CAN_IT_FF0:
   1515                  /* Check CAN_RF0R_FULL0 bit */
   1516                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
   1517                  break;
   1518                case CAN_IT_FOV0:
   1519                  /* Check CAN_RF0R_FOVR0 bit */
   1520                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
   1521                  break;
   1522                case CAN_IT_FMP1:
   1523                  /* Check CAN_RF1R_FMP1 bit */
   1524                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
   1525                  break;
   1526                case CAN_IT_FF1:
   1527                  /* Check CAN_RF1R_FULL1 bit */
   1528                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
   1529                  break;
   1530                case CAN_IT_FOV1:
   1531                  /* Check CAN_RF1R_FOVR1 bit */
   1532                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
   1533                  break;
   1534                case CAN_IT_WKU:
   1535                  /* Check CAN_MSR_WKUI bit */
   1536                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
   1537                  break;
   1538                case CAN_IT_SLK:
   1539                  /* Check CAN_MSR_SLAKI bit */
   1540                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
   1541                  break;
   1542                case CAN_IT_EWG:
   1543                  /* Check CAN_ESR_EWGF bit */
   1544                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
   1545                  break;
   1546                case CAN_IT_EPV:
   1547                  /* Check CAN_ESR_EPVF bit */
   1548                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
   1549                  break;
   1550                case CAN_IT_BOF:
   1551                  /* Check CAN_ESR_BOFF bit */
   1552                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
   1553                  break;
   1554                case CAN_IT_LEC:
   1555                  /* Check CAN_ESR_LEC bit */
   1556                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
   1557                  break;
   1558                case CAN_IT_ERR:
   1559                  /* Check CAN_MSR_ERRI bit */ 
   1560                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
   1561                  break;
   1562                default:
   1563                  /* in case of error, return RESET */
   1564                  itstatus = RESET;
   1565                  break;
   1566              }
   1567            }
   1568            else
   1569            {
   1570             /* in case the Interrupt is not enabled, return RESET */
   1571              itstatus  = RESET;
   1572            }
   1573            
   1574            /* Return the CAN_IT status */
   1575            return  itstatus;
   1576          }
   1577          
   1578          /**
   1579            * @brief  Clears the CANx's interrupt pending bits.
   1580            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1581            * @param  CAN_IT: specifies the interrupt pending bit to clear.
   1582            *          This parameter can be one of the following values:
   1583            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt
   1584            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1585            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1586            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1587            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1588            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1589            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1590            *            @arg CAN_IT_EWG: Error warning Interrupt
   1591            *            @arg CAN_IT_EPV: Error passive Interrupt
   1592            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1593            *            @arg CAN_IT_LEC: Last error code Interrupt
   1594            *            @arg CAN_IT_ERR: Error Interrupt 
   1595            * @retval None
   1596            */
   1597          void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1598          {
   1599            /* Check the parameters */
   1600            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1601            assert_param(IS_CAN_CLEAR_IT(CAN_IT));
   1602          
   1603            switch (CAN_IT)
   1604            {
   1605              case CAN_IT_TME:
   1606                /* Clear CAN_TSR_RQCPx (rc_w1)*/
   1607                CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
   1608                break;
   1609              case CAN_IT_FF0:
   1610                /* Clear CAN_RF0R_FULL0 (rc_w1)*/
   1611                CANx->RF0R = CAN_RF0R_FULL0; 
   1612                break;
   1613              case CAN_IT_FOV0:
   1614                /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
   1615                CANx->RF0R = CAN_RF0R_FOVR0; 
   1616                break;
   1617              case CAN_IT_FF1:
   1618                /* Clear CAN_RF1R_FULL1 (rc_w1)*/
   1619                CANx->RF1R = CAN_RF1R_FULL1;  
   1620                break;
   1621              case CAN_IT_FOV1:
   1622                /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
   1623                CANx->RF1R = CAN_RF1R_FOVR1; 
   1624                break;
   1625              case CAN_IT_WKU:
   1626                /* Clear CAN_MSR_WKUI (rc_w1)*/
   1627                CANx->MSR = CAN_MSR_WKUI;  
   1628                break;
   1629              case CAN_IT_SLK:
   1630                /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
   1631                CANx->MSR = CAN_MSR_SLAKI;   
   1632                break;
   1633              case CAN_IT_EWG:
   1634                /* Clear CAN_MSR_ERRI (rc_w1) */
   1635                CANx->MSR = CAN_MSR_ERRI;
   1636                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
   1637                break;
   1638              case CAN_IT_EPV:
   1639                /* Clear CAN_MSR_ERRI (rc_w1) */
   1640                CANx->MSR = CAN_MSR_ERRI; 
   1641                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1642                break;
   1643              case CAN_IT_BOF:
   1644                /* Clear CAN_MSR_ERRI (rc_w1) */ 
   1645                CANx->MSR = CAN_MSR_ERRI; 
   1646                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1647                 break;
   1648              case CAN_IT_LEC:
   1649                /*  Clear LEC bits */
   1650                CANx->ESR = RESET; 
   1651                /* Clear CAN_MSR_ERRI (rc_w1) */
   1652                CANx->MSR = CAN_MSR_ERRI; 
   1653                break;
   1654              case CAN_IT_ERR:
   1655                /*Clear LEC bits */
   1656                CANx->ESR = RESET; 
   1657                /* Clear CAN_MSR_ERRI (rc_w1) */
   1658                CANx->MSR = CAN_MSR_ERRI; 
   1659                 /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
   1660                 break;
   1661              default:
   1662                 break;
   1663             }
   1664          }
   1665           /**
   1666            * @}
   1667            */
   1668          
   1669          /**
   1670            * @brief  Checks whether the CAN interrupt has occurred or not.
   1671            * @param  CAN_Reg: specifies the CAN interrupt register to check.
   1672            * @param  It_Bit: specifies the interrupt source bit to check.
   1673            * @retval The new state of the CAN Interrupt (SET or RESET).
   1674            */
   1675          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
   1676          {
   1677            ITStatus pendingbitstatus = RESET;
   1678            
   1679            if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
   1680            {
   1681              /* CAN_IT is set */
   1682              pendingbitstatus = SET;
   1683            }
   1684            else
   1685            {
   1686              /* CAN_IT is reset */
   1687              pendingbitstatus = RESET;
   1688            }
   1689            return pendingbitstatus;
   1690          }
   1691          
   1692          /**
   1693            * @}
   1694            */
   1695          
   1696          /**
   1697            * @}
   1698            */
   1699          
   1700          /**
   1701            * @}
   1702            */
   1703          
   1704          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CAN_CancelTransmit
       0   CAN_ClearFlag
       0   CAN_ClearITPendingBit
       0   CAN_DBGFreeze
       8   CAN_DeInit
         0   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB1PeriphResetCmd
       0   CAN_FIFORelease
      12   CAN_FilterInit
       0   CAN_GetFlagStatus
       0   CAN_GetITStatus
       0   CAN_GetLSBTransmitErrorCounter
       0   CAN_GetLastErrorCode
       0   CAN_GetReceiveErrorCounter
       0   CAN_ITConfig
       8   CAN_Init
       0   CAN_MessagePending
       0   CAN_OperatingModeRequest
       0   CAN_Receive
       0   CAN_SlaveStartBank
       0   CAN_Sleep
       0   CAN_StructInit
       0   CAN_TTComModeCmd
      12   CAN_Transmit
       0   CAN_TransmitStatus
       0   CAN_WakeUp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
      40  CAN_CancelTransmit
      44  CAN_ClearFlag
     114  CAN_ClearITPendingBit
      18  CAN_DBGFreeze
      64  CAN_DeInit
      22  CAN_FIFORelease
     176  CAN_FilterInit
      48  CAN_GetFlagStatus
     184  CAN_GetITStatus
       8  CAN_GetLSBTransmitErrorCounter
       8  CAN_GetLastErrorCode
       6  CAN_GetReceiveErrorCounter
      16  CAN_ITConfig
     222  CAN_Init
      22  CAN_MessagePending
     144  CAN_OperatingModeRequest
     184  CAN_Receive
      40  CAN_SlaveStartBank
      30  CAN_Sleep
      32  CAN_StructInit
      94  CAN_TTComModeCmd
     190  CAN_Transmit
      74  CAN_TransmitStatus
      40  CAN_WakeUp

 
 1 856 bytes in section .text
 
 1 856 bytes of CODE memory

Errors: none
Warnings: none
